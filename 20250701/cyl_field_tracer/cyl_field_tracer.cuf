
program main
  use rk4
  use eqdsk_reader
  use field_cal
  use interp
  use deriv
  implicit none
  ! iteration 변수
  integer :: steps = 1000   ! 총 iteration 수
  real(8) :: dt = 1.0d-2    ! 시간 간격
  integer :: zip = 10       ! 출력 압축률

  ! 아래는 전부 의존성 없이 초기위치 정의 및 iteration 실행에 필요한 부분임.
  real(8), dimension(3) :: r
  real(8) :: t, x01, y01, z01
  integer :: istep, j, k
  real(8), dimension(3) :: grid_value
  real(8), dimension(3) :: k1, k2, k3, k4, drdt, r_temp
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
  character(len=100) :: filename   !저장 dat 이름
  type(eqdsk_data) :: eq    ! eqdsk_data 타입 선언
  real(8), allocatable :: rgrid(:), zgrid(:)   !eqdsk의 그리드 값들
  real(8), allocatable :: Br(:,:), Bz(:,:), Bphi(:,:)  ! 자기장 그리드
  real(8) :: B_r, B_z, B_phi ! 점에서 자기장 성분

  


  call read_eqdsk("g147131.02300_DIIID_KEFIT", eq)  !eqdsk 파일 읽기
  allocate(rgrid(eq%nw), zgrid(eq%nh))

  ! R 격자 생성
  do i = 1, eq%nw
    rgrid(i) = eq%rleft + eq%rdim * (i - 1) / (eq%nw - 1)
  end do

  ! Z 격자 생성
  do i = 1, eq%nh
    zgrid(i) = eq%zmid-eq%zdim/2 + eq%zdim * (i - 1) / (eq%nh - 1)
  end do

  allocate(Br(eq%nw, eq%nh))
  allocate(Bz(eq%nw, eq%nh))
  allocate(Bphi(eq%nw, eq%nh))
  ! 자기장 그리드 만들기(중요!)
  call B_cal(eq%psi, rgrid, zgrid, eq%fpol, Br, Bz, Bphi, eq%nw, eq%nh)

  
  filename = "Mag_trace.dat"

  open(unit=10, file=filename, status='replace', action='write', form='formatted')

  

  grid_value=(/-0.6d0, 0.0d0, 0.6d0/)   !초기위치 여러개 설정
  do j=1,3
  do k=1,3
  x01=grid_value(j)
  y01=grid_value(k)  
  z01=0.0d0
  r = (/x01,y01,z01/)  ! 초기 위치
    do istep = 0, steps
      t = istep * dt
      if (mod(istep, zip) == 0) then
        write(10,'(F12.6,3(1x,E16.8E3))') t, r(1), r(2), r(3)
        
      end if


      
      !!!!!!!!!!!!!!!!!!!!! rk4 그냥 main에서 수동으로 실행
      B_r=bilinear_interp(r(1),r(2), rgrid, zgrid, Br, eq%nw, eq%nh)
      B_z=bilinear_interp(r(1),r(2), rgrid, zgrid, Bz, eq%nw, eq%nh)
      B_phi=bilinear_interp(r(1),r(2), rgrid, zgrid, Bphi, eq%nw, eq%nh)
      ! 점에서 자기장 성분 계산
      call compute_deriv(r, B_r, B_z, B_phi, k1)
      r_temp = r + 0.5d0 * dt * k1
      B_r=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Br, eq%nw, eq%nh)
      B_z=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bz, eq%nw, eq%nh)
      B_phi=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bphi, eq%nw, eq%nh)
      call compute_deriv(r_temp, B_r, B_z, B_phi, k2)
      r_temp = r + 0.5d0 * dt * k2
      B_r=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Br, eq%nw, eq%nh)
      B_z=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bz, eq%nw, eq%nh)
      B_phi=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bphi, eq%nw, eq%nh)
      call compute_deriv(r_temp, B_r, B_z, B_phi, k3)
      r_temp = r + dt * k3
      B_r=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Br, eq%nw, eq%nh)
      B_z=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bz, eq%nw, eq%nh)
      B_phi=bilinear_interp(r_temp(1),r_temp(2), rgrid, zgrid, Bphi, eq%nw, eq%nh)
      call compute_deriv(r_temp, B_r, B_z, B_phi, k4)
      drdt = (k1 + 2.d0*k2 + 2.d0*k3 + k4) / 6.d0
      r = r + dt * drdt
      !!!!!!!!!!!!!!!!!!!!!rk4 끝



    end do
  end do
  end do

  close(10)
end program main
